/// <reference types="https://esm.sh/@supabase/functions-js/src/edge-runtime.d.ts" />

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { corsHeaders } from '../_shared/cors.ts'

// Define expected request body structure
interface ImportCatalogPayload {
  artistId: string; // The Supabase UUID of the artist
}

// Define the structure of your Song data (align with DB schema and types)
// From schema.sql: id (UUID PK), name, artist_id (UUID FK), spotify_id (TEXT UNIQUE),
// duration_ms, popularity, preview_url, vote_count, created_at, updated_at
interface Song {
  id?: string; // Primary Key (UUID), generated by DB or preserved if existing
  name: string;
  artist_id: string; // Foreign key to artists table (UUID) - MUST be provided
  spotify_id: string; // Spotify ID - MUST be provided for upsert conflict
  duration_ms?: number | null;
  popularity?: number | null;
  preview_url?: string | null;
  // vote_count is likely managed elsewhere, default in DB
  created_at?: string;
  updated_at?: string;
}

// Helper to get Spotify Access Token (Client Credentials Flow)
async function getSpotifyToken(): Promise<string | null> {
  const clientId = Deno.env.get('SPOTIFY_CLIENT_ID');
  const clientSecret = Deno.env.get('SPOTIFY_CLIENT_SECRET');

  if (!clientId || !clientSecret) {
    console.error('[import-spotify-catalog] Spotify client ID or secret not configured.');
    return null;
  }

  try {
    const response = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': 'Basic ' + btoa(clientId + ':' + clientSecret)
      },
      body: 'grant_type=client_credentials'
    });

    if (!response.ok) {
      console.error('[import-spotify-catalog] Failed to get Spotify token:', response.status, await response.text());
      return null;
    }
    const data = await response.json();
    return data.access_token;
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    console.error('[import-spotify-catalog] Error fetching Spotify token:', errorMsg);
    return null;
  }
}

// Helper to fetch paginated data from Spotify
async function fetchSpotifyPaginated(url: string, token: string, limit = 50) {
  let items: any[] = [];
  let nextUrl: string | null = `${url}${url.includes('?') ? '&' : '?'}limit=${limit}`;

  while (nextUrl) {
    try {
      console.log(`[import-spotify-catalog] Fetching Spotify page: ${nextUrl}`);
      const response = await fetch(nextUrl, {
        headers: { 'Authorization': `Bearer ${token}` }
      });

      if (!response.ok) {
        console.error(`[import-spotify-catalog] Spotify API error (${response.status}) for ${nextUrl}: ${await response.text()}`);
        break; // Stop pagination on error
      }

      const data = await response.json();
      // Spotify API structure varies (e.g., albums.items, tracks.items, or just items)
      const pageItems = data.items || data.tracks?.items || data.albums?.items || [];
      items = items.concat(pageItems);
      nextUrl = data.next; // Get URL for the next page

      // Optional: Add a small delay to avoid rate limiting
      if (nextUrl) {
        await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay
      }

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`[import-spotify-catalog] Error during Spotify pagination for ${nextUrl}:`, errorMsg);
      break; // Stop pagination on error
    }
  }
  return items;
}


serve(async (req: Request) => {
  // Handle CORS preflight request
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const payload: ImportCatalogPayload = await req.json();
    const { artistId } = payload; // This is the Supabase UUID

    if (!artistId) {
      return new Response(JSON.stringify({ error: 'Missing artistId (Supabase UUID) in request body' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      })
    }

    console.log(`[import-spotify-catalog] Received request for artist UUID: ${artistId}`);

    // Initialize Supabase client with SERVICE_ROLE key
    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // 1. Get Artist's Spotify ID from DB
    let spotifyArtistId: string | null = null;
    try {
      const { data: artistData, error: artistError } = await supabaseAdmin
        .from('artists')
        .select('spotify_id')
        .eq('id', artistId) // Match using Supabase UUID
        .single(); // Expect exactly one artist

      if (artistError) {
        console.error(`[import-spotify-catalog] Error fetching artist ${artistId}:`, artistError.message);
        throw new Error(`Artist with UUID ${artistId} not found or error fetching.`);
      }
      if (!artistData?.spotify_id) {
         throw new Error(`Artist ${artistId} does not have a Spotify ID.`);
      }
      spotifyArtistId = artistData.spotify_id;
      console.log(`[import-spotify-catalog] Found Spotify ID ${spotifyArtistId} for artist ${artistId}`);

    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      return new Response(JSON.stringify({ error: `Failed to get Spotify ID for artist ${artistId}: ${errorMsg}` }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 404, // Or 500 depending on error type
      })
    }

    // 2. Get Spotify Token
    const token = await getSpotifyToken();
    if (!token) {
      return new Response(JSON.stringify({ error: 'Failed to obtain Spotify API token' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      })
    }

    // 3. Fetch All Albums for the Artist
    console.log(`[import-spotify-catalog] Fetching albums for Spotify artist ${spotifyArtistId}...`);
    const albumsUrl = `https://api.spotify.com/v1/artists/${spotifyArtistId}/albums`;
    // Include singles, appears_on etc. if desired, adjust 'include_groups'
    const albums = await fetchSpotifyPaginated(`${albumsUrl}?include_groups=album,single`, token);
    console.log(`[import-spotify-catalog] Found ${albums.length} albums/singles for artist ${spotifyArtistId}.`);

    if (albums.length === 0) {
       console.log(`[import-spotify-catalog] No albums found for artist ${spotifyArtistId}. No songs to import.`);
       return new Response(JSON.stringify({ success: true, message: 'No albums found, 0 songs imported.' }), {
         headers: { ...corsHeaders, 'Content-Type': 'application/json' },
         status: 200,
       })
    }

    // 4. Fetch Tracks for Each Album & Consolidate
    const allTracks = new Map<string, any>(); // Use Map to automatically handle duplicates by Spotify ID
    for (const album of albums) {
      if (!album.id) continue;
      console.log(`[import-spotify-catalog] Fetching tracks for album ${album.id} (${album.name})...`);
      const tracksUrl = `https://api.spotify.com/v1/albums/${album.id}/tracks`;
      const tracks = await fetchSpotifyPaginated(tracksUrl, token);
      console.log(`[import-spotify-catalog] Found ${tracks.length} tracks for album ${album.id}.`);
      tracks.forEach(track => {
        if (track.id && !allTracks.has(track.id)) { // Fix: Use && instead of &amp;&amp;
           // Ensure the track is linked to the primary artist we are syncing
           // (Handles cases where the track artist list might differ slightly on compilations/features)
           const isPrimaryArtist = track.artists?.some((a: any) => a.id === spotifyArtistId);
           if (isPrimaryArtist) {
               allTracks.set(track.id, track);
           } else {
               // console.log(`[import-spotify-catalog] Skipping track ${track.id} (${track.name}) as primary artist ${spotifyArtistId} not listed.`);
           }
        }
      });
    }
    console.log(`[import-spotify-catalog] Total unique tracks found for artist ${spotifyArtistId}: ${allTracks.size}`);

    if (allTracks.size === 0) {
        console.log(`[import-spotify-catalog] No primary tracks found for artist ${spotifyArtistId} after filtering.`);
        return new Response(JSON.stringify({ success: true, message: 'No primary tracks found, 0 songs imported.' }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 200,
        })
    }

    // 5. Map Spotify Tracks to DB Song Schema
    const songsToUpsert: Song[] = Array.from(allTracks.values()).map(track => ({
      name: track.name,
      artist_id: artistId, // The Supabase UUID of the artist
      spotify_id: track.id, // Spotify track ID is the conflict target
      duration_ms: track.duration_ms || null,
      popularity: track.popularity ?? null, // Use nullish coalescing to default to null
      preview_url: track.preview_url || null,
      // Let created_at/updated_at be handled by DB
    }));

    // 6. Bulk Upsert Songs into Supabase
    console.log(`[import-spotify-catalog] Upserting ${songsToUpsert.length} songs into database...`);
    // Supabase has limits on bulk operation size, chunk if necessary (e.g., 500 per batch)
    const BATCH_SIZE = 500;
    let upsertedCount = 0;
    let failedCount = 0;

    for (let i = 0; i < songsToUpsert.length; i += BATCH_SIZE) {
        const batch = songsToUpsert.slice(i, i + BATCH_SIZE);
        console.log(`[import-spotify-catalog] Upserting batch ${i / BATCH_SIZE + 1} (${batch.length} songs)...`);
        const { data, error: upsertError } = await supabaseAdmin
            .from('songs')
            .upsert(batch, {
                onConflict: 'spotify_id', // Use Spotify ID to handle conflicts
                ignoreDuplicates: false // Ensure existing songs are updated if needed
            })
            .select('id'); // Select minimal data

        if (upsertError) {
            console.error(`[import-spotify-catalog] Supabase song upsert error (batch starting ${i}):`, upsertError);
            failedCount += batch.length; // Assume whole batch failed on error for simplicity
            // Consider more granular error handling if needed
        } else {
            upsertedCount += data?.length || 0; // Count successful upserts in the batch
        }
    }

    console.log(`[import-spotify-catalog] Finished upserting. Successful: ${upsertedCount}, Failed: ${failedCount}`);

    if (failedCount > 0) {
         // Partial success
         return new Response(JSON.stringify({
             success: false, // Indicate partial failure
             message: `Partially imported Spotify catalog for artist ${artistId}. Upserted: ${upsertedCount}, Failed: ${failedCount}`,
             upserted: upsertedCount,
             failed: failedCount
         }), {
             headers: { ...corsHeaders, 'Content-Type': 'application/json' },
             status: 207, // Multi-Status
         })
    }

    return new Response(JSON.stringify({
        success: true,
        message: `Successfully imported ${upsertedCount} songs for artist ${artistId}.`,
        songs_imported: upsertedCount
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    })

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    console.error('[import-spotify-catalog] Unhandled error:', errorMessage, error);
    return new Response(JSON.stringify({ error: errorMessage }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    })
  }
})
